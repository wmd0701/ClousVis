// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Iterator
// #pragma kernel ReconstructStreamLine

// Dimensions of the texture.
static const float xDim = 7504.0f;
static const float yDim = 7781.0f;
static const float zDim = 198.17;

// Maximal magnitudes of wind in each spatial dimension.
static const float minU = -13.1579f;
static const float maxU = 47.3699f;
static const float minV = -20.4191f;
static const float maxV = 50.6398f;
static const float minW = -11.276f;
static const float maxW = 15.765f;

// Buffer holding the initial positions of the particles.
RWStructuredBuffer<float3> seedBuff;

// Buffer holding the calculated positions for each trajectory.
RWStructuredBuffer<float3> streamlineBuff;

// Texture holding the vectorfield.
Texture3D<float4> vectorfieldTexture;
SamplerState sampler_vectorfieldTexture;
SamplerState my_trilinear_repeat_sampler;

// Buffer holding general information.
uint maxStreamlineCount;
uint streamlineCount;
uint iteratorSteps;
float stepSize;

float3 Decode(float4 encoding) {

    // The actual decoding.
    float U = encoding.r * (maxU - minU) + minU;
    float V = encoding.g * (maxV - minV) + minV;
    float W = encoding.b * (maxW - minW) + minW;

    return float3(U, V, W);
}

float4 SampleVectorField(float3 position) {

    // Calculate uvw based on position.
    float u = position.x / xDim;
    float v = position.y / yDim;
    float w = position.z / zDim;
    float3 uvw = float3(u, v, w);
    return vectorfieldTexture.SampleLevel(my_trilinear_repeat_sampler, uvw, 0);
}

float3 RK4Step(float3 x, float h) {
    float3 k1 = Decode(SampleVectorField(x));
    float3 k2 = Decode(SampleVectorField(x + h / 2.0f * k1));
    float3 k3 = Decode(SampleVectorField(x + h / 2.0f * k2));
    float3 k4 = Decode(SampleVectorField(x + h * k3));
    x += (k1 / 2.0f + k2 + k3 + k4 / 2.0f) / 3.0f * h;
    return x;
}

[numthreads(64,1,1)]
void Iterator(uint id: SV_DispatchThreadID) {
    
    // Get initial position and store it.
    float3 position = seedBuff[id];

    for (uint i = 0; i < iteratorSteps; i++) {
        streamlineBuff[id + i * maxStreamlineCount] = position;
        position = RK4Step(position, stepSize);
    }
}

